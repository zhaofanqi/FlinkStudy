JMM: java memory model。由于CPU读写速度大于主内存中的，因而中间存在多级缓存，从而CPU的变量与主内存中的可能存在不一致，因而有内存一致性协议
JMM作用：实现线程与主内存之间的抽象关系；屏蔽各个硬件平台与操作系统的内存访问差异，以实现让java程序在各个平台下达到一致的内存访问效果
JMM 本身是是一种抽象的概念并不真实存在，它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并
决定一个线程对共享变量的写入，何时以及如何变成对另一个线程可见，关键点都是围绕多线程的 可见行，原子性和有序性展开

可见性：是指当一个线程修改共享变量时，其他线程是否能立刻知道该变更。JMM规定了所有的变量都存在主内存中

系统主内存 共享变量数据修改 的写入时机不确定，多线程并发下很可能出现"脏读"，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程
使用到变量的 主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在线程自己的工作内存中进行，而不能直接读写主内存中的变量。不同线程之间
也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存完成

原子性：指一个线程的操作不可以被打断，即多线程环境下，操作不被其他线程干扰

有序性：只要程序的最终执行结果与他顺序化执行的结相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重拍序
处理器在进行重拍序时必须考虑指令之间的依赖性

volatile 可见性 有序性(内存屏障保证)
第一步       ｜            第二步
            ｜  普通读写      volatile读      volatile写
普通读写     ｜ 可以重排        可以重排        不可以重排
volatile读  ｜  不可以重排     不可以重排        不可以重排
volatile写  ｜  可以重排       不可以重排        不可以重排